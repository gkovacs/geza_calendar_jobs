#!/usr/bin/env node
// Generated by LiveScript 1.4.0
(function(){
  var getsecret, moment, cfy, google, calendar, key, auth, calendarId, primary_calendarId, postpone_event, delete_passed_events, replace_calendly_urls, add_scheduling_links;
  getsecret = require('getsecret');
  moment = require('moment');
  cfy = require('cfy').cfy;
  google = require('googleapis');
  calendar = google.calendar('v3');
  key = JSON.parse(getsecret('google_service_account'));
  auth = new google.auth.JWT(key.client_email, null, key.private_key, ['https://www.googleapis.com/auth/calendar'], null);
  auth.projectId = key.project_id;
  calendarId = getsecret('available_meals_calendar_id');
  primary_calendarId = getsecret('primary_calendar_id');
  postpone_event = function(evt, number, unit){
    var new_start, new_end;
    new_start = moment(evt.start.dateTime).add(number, unit).format("YYYY-MM-DDTHH:mm:ssZ");
    new_end = moment(evt.end.dateTime).add(number, unit).format("YYYY-MM-DDTHH:mm:ssZ");
    evt.start.dateTime = new_start;
    return evt.end.dateTime = new_end;
  };
  delete_passed_events = cfy(function*(it){
    var tokens, events, event_list, ref$, i$, len$, evt, start_time, end_time, eventId, results$ = [];
    tokens = (yield function(it){
      return auth.authorize(it);
    });
    events = (yield function(it){
      return calendar.events.list({
        auth: auth,
        calendarId: calendarId
      }, {}, it);
    });
    event_list = events != null ? (ref$ = events[0]) != null ? ref$.items : void 8 : void 8;
    for (i$ = 0, len$ = event_list.length; i$ < len$; ++i$) {
      evt = event_list[i$];
      if ((evt != null ? evt.start : void 8) == null || (evt != null ? evt.end : void 8) == null) {
        continue;
      }
      start_time = moment(new Date(evt.start.dateTime));
      end_time = moment(new Date(evt.end.dateTime));
      if (moment().add(1, 'hours') >= start_time) {
        eventId = evt.id;
        if (evt.recurrence && start_time.add(1, 'weeks') < end_time && evt.recurrence.filter(it(fn$)).length > 0) {
          postpone_event(evt, 1, 'weeks');
          results$.push((yield fn1$));
        } else {
          results$.push((yield fn2$));
        }
      }
    }
    return results$;
    function fn$(it){
      return it.includes('RRULE:FREQ=WEEKLY');
    }
    function fn1$(it){
      return calendar.events.patch({
        auth: auth,
        calendarId: calendarId,
        eventId: eventId,
        resource: evt
      }, it);
    }
    function fn2$(it){
      return calendar.events['delete']({
        auth: auth,
        calendarId: calendarId,
        eventId: eventId
      }, it);
    }
  });
  replace_calendly_urls = cfy(function*(){
    var timeMin, events, event_list, ref$, i$, len$, evt, eventId, ndesc, j$, ref1$, len1$, description_line, results$ = [];
    timeMin = moment().format("YYYY-MM-DDTHH:mm:ssZ");
    events = (yield function(it){
      return calendar.events.list({
        auth: auth,
        calendarId: primary_calendarId,
        timeMin: timeMin
      }, {}, it);
    });
    event_list = events != null ? (ref$ = events[0]) != null ? ref$.items : void 8 : void 8;
    for (i$ = 0, len$ = event_list.length; i$ < len$; ++i$) {
      evt = event_list[i$];
      eventId = evt.id;
      if (evt.description != null) {
        if (evt.description.indexOf('https://calendly.com/cancellations/') !== -1 || evt.description.indexOf('https://calendly.com/reschedulings/') !== -1) {
          ndesc = [];
          for (j$ = 0, len1$ = (ref1$ = evt.description.split('\n')).length; j$ < len1$; ++j$) {
            description_line = ref1$[j$];
            if (description_line.indexOf('https://calendly.com/cancellations/') !== -1 || description_line.indexOf('https://calendly.com/reschedulings/') !== -1) {
              ndesc.push('https://calendly.com/dashboard');
            } else {
              ndesc.push(description_line);
            }
          }
          evt.description = ndesc.join('\n');
          results$.push((yield fn$));
        }
      }
    }
    return results$;
    function fn$(it){
      return calendar.events.patch({
        auth: auth,
        calendarId: primary_calendarId,
        eventId: eventId,
        resource: evt
      }, it);
    }
  });
  add_scheduling_links = cfy(function*(){
    var events, event_list, ref$, i$, len$, evt, eventId, start_time, end_time, meal_type, title_printable, description_printable, results$ = [];
    events = (yield function(it){
      return calendar.events.list({
        auth: auth,
        calendarId: calendarId
      }, {}, it);
    });
    event_list = events != null ? (ref$ = events[0]) != null ? ref$.items : void 8 : void 8;
    for (i$ = 0, len$ = event_list.length; i$ < len$; ++i$) {
      evt = event_list[i$];
      if ((evt != null ? evt.start : void 8) == null || (evt != null ? evt.end : void 8) == null) {
        continue;
      }
      eventId = evt.id;
      start_time = moment(new Date(evt.start.dateTime));
      end_time = moment(new Date(evt.end.dateTime));
      if (evt.summary === 'available' || evt.summary === '[dinner] available' || evt.summary === '[lunch] available') {
        meal_type = 'lunch';
        if (start_time.hour() >= 15) {
          meal_type = 'dinner';
        }
        title_printable = "[" + meal_type + "] available " + start_time.format('hh:mma') + " - " + end_time.format('hh:mma') + " book at https://gkovacs.com/meet";
        description_printable = '<a href="https://www.gkovacs.com/meet">https://www.gkovacs.com/meet</a>';
        evt.description = description_printable;
        evt.summary = title_printable;
        results$.push((yield fn$));
      }
    }
    return results$;
    function fn$(it){
      return calendar.events.patch({
        auth: auth,
        calendarId: calendarId,
        eventId: eventId,
        resource: evt
      }, it);
    }
  });
  /*
  is_between_time = (evt, start, end) ->
    evt_start = moment(new Date(evt.start.dateTime))
    evt_end = moment(new Date(evt.end.dateTime))
    return (evt_start < end and evt_end >= start) or (evt_start <= end and evt_end > start)
  
  to_timestamp_minutes = (moment_obj) ->
    Math.round(moment(moment_obj).seconds(0).milliseconds(0).unix() / 60)
  
  get_nonconflicting_spans_all = (conflicting_events, start, end) ->
    start_timestamp_minutes = to_timestamp_minutes start
    end_timestamp_minutes = to_timestamp_minutes end
    length_minutes = end_timestamp_minutes - start_timestamp_minutes
    conflicts = [false]*length_minutes
    for evt in conflicting_events
      evt_start_minutes = to_timestamp_minutes(new Date(evt.start.dateTime))
      evt_end_minutes = to_timestamp_minutes(new Date(evt.end.dateTime))
      for offset from Math.max(0, evt_start_minutes - start_timestamp_minutes) til Math.min(length_minutes, evt_end_minutes - start_timestamp_minutes)
        conflicts[offset] = true
    #console.log conflicts
    start_time_to_lengths = [0]*length_minutes
    streak_start_idx = 0
    for val,idx in conflicts
      if val
        streak_start_idx = idx + 1
      else
        start_time_to_lengths[streak_start_idx] += 1
    #console.log start_time_to_lengths
    output = []
    for val,idx in start_time_to_lengths
      if val > 0
        span_start = moment(start).add(idx, 'minutes')
        span_end = moment(start).add(val, 'minutes')
        output.push {start: span_start, end: span_end, minutes: val}
    return output
  
  get_nonconflicting_spans = (conflicting_events, start, end) ->
    output = get_nonconflicting_spans_all conflicting_events, start, end
    return output.filter(-> it.minutes >= 60)
  
  nonditchable_and_nontentative = (evt) ->
    if not evt?
      return false
    summary = evt.summary
    if not summary?
      return false
    return not (summary.includes('[ditchable]') or summary.includes('[tentative]'))
  
  create_available_meals = cfy ->*
    timeMin = moment().format("YYYY-MM-DDTHH:mm:ssZ")
    events_available_meals = (yield -> calendar.events.list {auth, calendarId, timeMin}, {}, it)?0?items
    events_meals = (yield -> calendar.events.list {auth, calendarId: meals_calendarId, timeMin}, {}, it)?0?items
    events_primary = (yield -> calendar.events.list {auth, calendarId: primary_calendarId, timeMin}, {}, it)?0?items
    events_secondary = (yield -> calendar.events.list {auth, calendarId: secondary_calendarId, timeMin}, {}, it)?0?items
    current_time = moment()
    today_start = moment(current_time).hours(0).minutes(0).seconds(0).milliseconds(0)
    events_meals_actual = events_meals.filter(nonditchable_and_nontentative)
    events_all_actual = events_primary.concat(events_secondary).concat(events_meals).filter(nonditchable_and_nontentative)
    console.log events_primary.filter(-> it.recurrence?)
    # TODO need to check overlap with recurring events as well
    for days_into_future from 0 til 1
      day = moment(today_start).add(days_into_future, 'days')
      next_day = moment(day).add(1, 'days')
      lunchtime_start = moment(day).hours(11).minutes(50)
      lunchtime_end = moment(day).hours(14)
      events_all_lunchtime = events_all_actual.filter(-> is_between_time(it, lunchtime_start, lunchtime_end))
      #console.log events_all_lunchtime
      #console.log get_nonconflicting_spans_all(events_all_lunchtime, lunchtime_start, lunchtime_end)
      available_meals_to_output = []
  */
  delete_passed_events();
  replace_calendly_urls();
  add_scheduling_links();
}).call(this);
