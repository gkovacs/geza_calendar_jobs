#!/usr/bin/env node
// Generated by LiveScript 1.4.0
(function(){
  var getsecret, moment, cfy, google, calendar, key, auth, calendarId, primary_calendarId, postpone_event, delete_passed_events, replace_calendly_urls, add_scheduling_links;
  getsecret = require('getsecret');
  moment = require('moment');
  cfy = require('cfy').cfy;
  google = require('googleapis');
  calendar = google.calendar('v3');
  key = JSON.parse(getsecret('google_service_account'));
  auth = new google.auth.JWT(key.client_email, null, key.private_key, ['https://www.googleapis.com/auth/calendar'], null);
  auth.projectId = key.project_id;
  calendarId = getsecret('available_meals_calendar_id');
  primary_calendarId = getsecret('primary_calendar_id');
  postpone_event = function(evt, number, unit){
    var new_start, new_end;
    new_start = moment(evt.start.dateTime).add(number, unit).format("YYYY-MM-DDTHH:mm:ssZ");
    new_end = moment(evt.end.dateTime).add(number, unit).format("YYYY-MM-DDTHH:mm:ssZ");
    evt.start.dateTime = new_start;
    return evt.end.dateTime = new_end;
  };
  delete_passed_events = cfy(function*(){
    var tokens, events, event_list, ref$, i$, len$, evt, start_time, end_time, eventId, results$ = [];
    tokens = (yield function(it){
      return auth.authorize(it);
    });
    events = (yield function(it){
      return calendar.events.list({
        auth: auth,
        calendarId: calendarId
      }, {}, it);
    });
    event_list = events != null ? (ref$ = events[0]) != null ? ref$.items : void 8 : void 8;
    for (i$ = 0, len$ = event_list.length; i$ < len$; ++i$) {
      evt = event_list[i$];
      if ((evt != null ? evt.start : void 8) == null || (evt != null ? evt.end : void 8) == null) {
        continue;
      }
      start_time = moment(new Date(evt.start.dateTime));
      end_time = moment(new Date(evt.end.dateTime));
      if (moment().add(1, 'hours') >= start_time) {
        eventId = evt.id;
        if (evt.recurrence && start_time.add(1, 'weeks') < end_time && evt.recurrence[0].indexOf('RRULE:FREQ=WEEKLY') !== -1) {
          postpone_event(evt, 1, 'weeks');
          results$.push((yield fn$));
        } else {
          results$.push((yield fn1$));
        }
      }
    }
    return results$;
    function fn$(it){
      return calendar.events.patch({
        auth: auth,
        calendarId: calendarId,
        eventId: eventId,
        resource: evt
      }, it);
    }
    function fn1$(it){
      return calendar.events['delete']({
        auth: auth,
        calendarId: calendarId,
        eventId: eventId
      }, it);
    }
  });
  replace_calendly_urls = cfy(function*(){
    var timeMin, events, event_list, ref$, i$, len$, evt, eventId, ndesc, j$, ref1$, len1$, description_line, results$ = [];
    timeMin = moment().format("YYYY-MM-DDTHH:mm:ssZ");
    events = (yield function(it){
      return calendar.events.list({
        auth: auth,
        calendarId: primary_calendarId,
        timeMin: timeMin
      }, {}, it);
    });
    event_list = events != null ? (ref$ = events[0]) != null ? ref$.items : void 8 : void 8;
    for (i$ = 0, len$ = event_list.length; i$ < len$; ++i$) {
      evt = event_list[i$];
      eventId = evt.id;
      if (evt.description != null) {
        if (evt.description.indexOf('https://calendly.com/cancellations/') !== -1 || evt.description.indexOf('https://calendly.com/reschedulings/') !== -1) {
          ndesc = [];
          for (j$ = 0, len1$ = (ref1$ = evt.description.split('\n')).length; j$ < len1$; ++j$) {
            description_line = ref1$[j$];
            if (description_line.indexOf('https://calendly.com/cancellations/') !== -1 || description_line.indexOf('https://calendly.com/reschedulings/') !== -1) {
              ndesc.push('https://calendly.com/dashboard');
            } else {
              ndesc.push(description_line);
            }
          }
          evt.description = ndesc.join('\n');
          results$.push((yield fn$));
        }
      }
    }
    return results$;
    function fn$(it){
      return calendar.events.patch({
        auth: auth,
        calendarId: primary_calendarId,
        eventId: eventId,
        resource: evt
      }, it);
    }
  });
  add_scheduling_links = cfy(function*(){
    var events, event_list, ref$, i$, len$, evt, eventId, start_time, end_time, meal_type, title_printable, description_printable, results$ = [];
    events = (yield function(it){
      return calendar.events.list({
        auth: auth,
        calendarId: calendarId
      }, {}, it);
    });
    event_list = events != null ? (ref$ = events[0]) != null ? ref$.items : void 8 : void 8;
    for (i$ = 0, len$ = event_list.length; i$ < len$; ++i$) {
      evt = event_list[i$];
      if ((evt != null ? evt.start : void 8) == null || (evt != null ? evt.end : void 8) == null) {
        continue;
      }
      eventId = evt.id;
      start_time = moment(new Date(evt.start.dateTime));
      end_time = moment(new Date(evt.end.dateTime));
      if (evt.summary === 'available' || evt.summary === '[dinner] available' || evt.summary === '[lunch] available') {
        meal_type = 'lunch';
        if (start_time.hour() >= 15) {
          meal_type = 'dinner';
        }
        title_printable = "[" + meal_type + "] available " + start_time.format('hh:mma') + " - " + end_time.format('hh:mma') + " book at https://gkovacs.com/meet";
        description_printable = '<a href="https://www.gkovacs.com/meet">https://www.gkovacs.com/meet</a>';
        evt.description = description_printable;
        evt.summary = title_printable;
        results$.push((yield fn$));
      }
    }
    return results$;
    function fn$(it){
      return calendar.events.patch({
        auth: auth,
        calendarId: calendarId,
        eventId: eventId,
        resource: evt
      }, it);
    }
  });
  delete_passed_events();
  replace_calendly_urls();
  add_scheduling_links();
}).call(this);
