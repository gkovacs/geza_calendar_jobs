#!/usr/bin/env node
// Generated by LiveScript 1.4.0
(function(){
  var getsecret, moment, cfy, google, calendar, key, auth, calendarId, meals_calendarId, primary_calendarId, secondary_calendarId, postpone_event, postpone_event_to_day, delete_passed_events, replace_calendly_urls, add_scheduling_links, is_between_time, to_timestamp_minutes, get_nonconflicting_spans_all, get_nonconflicting_spans, nonditchable_and_nontentative, is_weekly_recurring, get_recrule_day_of_week_indexes, get_next_time_given_day_of_week_indexes, expand_recurring_events, create_available_meals;
  getsecret = require('getsecret');
  moment = require('moment');
  cfy = require('cfy').cfy;
  google = require('googleapis');
  calendar = google.calendar('v3');
  key = JSON.parse(getsecret('google_service_account'));
  auth = new google.auth.JWT(key.client_email, null, key.private_key, ['https://www.googleapis.com/auth/calendar'], null);
  auth.projectId = key.project_id;
  calendarId = getsecret('available_meals_calendar_id');
  meals_calendarId = getsecret('meals_calendar_id');
  primary_calendarId = getsecret('primary_calendar_id');
  secondary_calendarId = getsecret('secondary_calendar_id');
  postpone_event = function(evt, number, unit){
    var new_start, new_end;
    new_start = moment(evt.start.dateTime).add(number, unit).format("YYYY-MM-DDTHH:mm:ssZ");
    new_end = moment(evt.end.dateTime).add(number, unit).format("YYYY-MM-DDTHH:mm:ssZ");
    evt.start.dateTime = new_start;
    return evt.end.dateTime = new_end;
  };
  postpone_event_to_day = function(evt, day){
    var orig_start, orig_end, new_start, new_end;
    orig_start = moment(evt.start.dateTime);
    orig_end = moment(evt.end.dateTime);
    new_start = moment(day).hours(orig_start.hours()).minutes(orig_start.minutes()).format("YYYY-MM-DDTHH:mm:ssZ");
    new_end = moment(day).hours(orig_end.hours()).minutes(orig_start.minutes()).format("YYYY-MM-DDTHH:mm:ssZ");
    evt.start.dateTime = new_start;
    return evt.end.dateTime = new_end;
  };
  delete_passed_events = cfy(function*(){
    var tokens, events, event_list, ref$, i$, len$, evt, start_time, end_time, eventId, results$ = [];
    tokens = (yield function(it){
      return auth.authorize(it);
    });
    events = (yield function(it){
      return calendar.events.list({
        auth: auth,
        calendarId: calendarId
      }, {}, it);
    });
    event_list = events != null ? (ref$ = events[0]) != null ? ref$.items : void 8 : void 8;
    for (i$ = 0, len$ = event_list.length; i$ < len$; ++i$) {
      evt = event_list[i$];
      if ((evt != null ? evt.start : void 8) == null || (evt != null ? evt.end : void 8) == null) {
        continue;
      }
      start_time = moment(new Date(evt.start.dateTime));
      end_time = moment(new Date(evt.end.dateTime));
      if (moment().add(1, 'hours') >= start_time) {
        eventId = evt.id;
        if (is_weekly_recurring(evt) && start_time.add(1, 'weeks') < end_time) {
          postpone_event(evt, 1, 'weeks');
          results$.push((yield fn$));
        } else {
          results$.push((yield fn1$));
        }
      }
    }
    return results$;
    function fn$(it){
      return calendar.events.patch({
        auth: auth,
        calendarId: calendarId,
        eventId: eventId,
        resource: evt
      }, it);
    }
    function fn1$(it){
      return calendar.events['delete']({
        auth: auth,
        calendarId: calendarId,
        eventId: eventId
      }, it);
    }
  });
  replace_calendly_urls = cfy(function*(){
    var timeMin, events, event_list, ref$, i$, len$, evt, eventId, ndesc, j$, ref1$, len1$, description_line, results$ = [];
    timeMin = moment().format("YYYY-MM-DDTHH:mm:ssZ");
    events = (yield function(it){
      return calendar.events.list({
        auth: auth,
        calendarId: primary_calendarId,
        timeMin: timeMin
      }, {}, it);
    });
    event_list = events != null ? (ref$ = events[0]) != null ? ref$.items : void 8 : void 8;
    for (i$ = 0, len$ = event_list.length; i$ < len$; ++i$) {
      evt = event_list[i$];
      eventId = evt.id;
      if (evt.description != null) {
        if (evt.description.indexOf('https://calendly.com/cancellations/') !== -1 || evt.description.indexOf('https://calendly.com/reschedulings/') !== -1) {
          ndesc = [];
          for (j$ = 0, len1$ = (ref1$ = evt.description.split('\n')).length; j$ < len1$; ++j$) {
            description_line = ref1$[j$];
            if (description_line.indexOf('https://calendly.com/cancellations/') !== -1 || description_line.indexOf('https://calendly.com/reschedulings/') !== -1) {
              ndesc.push('https://calendly.com/dashboard');
            } else {
              ndesc.push(description_line);
            }
          }
          evt.description = ndesc.join('\n');
          results$.push((yield fn$));
        }
      }
    }
    return results$;
    function fn$(it){
      return calendar.events.patch({
        auth: auth,
        calendarId: primary_calendarId,
        eventId: eventId,
        resource: evt
      }, it);
    }
  });
  add_scheduling_links = cfy(function*(){
    var events, event_list, ref$, i$, len$, evt, eventId, start_time, end_time, meal_type, title_printable, description_printable, results$ = [];
    events = (yield function(it){
      return calendar.events.list({
        auth: auth,
        calendarId: calendarId
      }, {}, it);
    });
    event_list = events != null ? (ref$ = events[0]) != null ? ref$.items : void 8 : void 8;
    for (i$ = 0, len$ = event_list.length; i$ < len$; ++i$) {
      evt = event_list[i$];
      if ((evt != null ? evt.start : void 8) == null || (evt != null ? evt.end : void 8) == null) {
        continue;
      }
      eventId = evt.id;
      start_time = moment(new Date(evt.start.dateTime));
      end_time = moment(new Date(evt.end.dateTime));
      if (evt.summary === 'available' || evt.summary === '[dinner] available' || evt.summary === '[lunch] available') {
        meal_type = 'lunch';
        if (start_time.hour() >= 15) {
          meal_type = 'dinner';
        }
        title_printable = "[" + meal_type + "] available " + start_time.format('h:mma') + " - " + end_time.format('h:mma') + " book at https://gkovacs.com/meet";
        description_printable = '<a href="https://www.gkovacs.com/meet">https://www.gkovacs.com/meet</a>';
        evt.description = description_printable;
        evt.summary = title_printable;
        results$.push((yield fn$));
      }
    }
    return results$;
    function fn$(it){
      return calendar.events.patch({
        auth: auth,
        calendarId: calendarId,
        eventId: eventId,
        resource: evt
      }, it);
    }
  });
  is_between_time = function(evt, start, end){
    var evt_start, evt_end;
    evt_start = moment(new Date(evt.start.dateTime));
    evt_end = moment(new Date(evt.end.dateTime));
    return (evt_start < end && evt_end >= start) || (evt_start <= end && evt_end > start);
  };
  to_timestamp_minutes = function(moment_obj){
    return Math.round(moment(moment_obj).seconds(0).milliseconds(0).unix() / 60);
  };
  get_nonconflicting_spans_all = function(conflicting_events, start, end){
    var start_timestamp_minutes, end_timestamp_minutes, length_minutes, conflicts, i$, len$, evt, evt_start_minutes, evt_end_minutes, j$, to$, offset, start_time_to_lengths, streak_start_idx, idx, val, output, span_start, span_end;
    start_timestamp_minutes = to_timestamp_minutes(start);
    end_timestamp_minutes = to_timestamp_minutes(end);
    length_minutes = end_timestamp_minutes - start_timestamp_minutes;
    conflicts = repeatArray$([false], length_minutes);
    for (i$ = 0, len$ = conflicting_events.length; i$ < len$; ++i$) {
      evt = conflicting_events[i$];
      evt_start_minutes = to_timestamp_minutes(new Date(evt.start.dateTime));
      evt_end_minutes = to_timestamp_minutes(new Date(evt.end.dateTime));
      for (j$ = Math.max(0, evt_start_minutes - start_timestamp_minutes), to$ = Math.min(length_minutes, evt_end_minutes - start_timestamp_minutes); j$ < to$; ++j$) {
        offset = j$;
        conflicts[offset] = true;
      }
    }
    start_time_to_lengths = repeatArray$([0], length_minutes);
    streak_start_idx = 0;
    for (i$ = 0, len$ = conflicts.length; i$ < len$; ++i$) {
      idx = i$;
      val = conflicts[i$];
      if (val) {
        streak_start_idx = idx + 1;
      } else {
        start_time_to_lengths[streak_start_idx] += 1;
      }
    }
    output = [];
    for (i$ = 0, len$ = start_time_to_lengths.length; i$ < len$; ++i$) {
      idx = i$;
      val = start_time_to_lengths[i$];
      if (val > 0) {
        span_start = moment(start).add(idx, 'minutes');
        span_end = moment(start).add(idx + val, 'minutes');
        output.push({
          start: span_start,
          end: span_end,
          minutes: val
        });
      }
    }
    return output;
  };
  get_nonconflicting_spans = function(conflicting_events, start, end){
    var output;
    output = get_nonconflicting_spans_all(conflicting_events, start, end);
    return output.filter(function(it){
      return it.minutes >= 60;
    });
  };
  nonditchable_and_nontentative = function(evt){
    var summary;
    if (evt == null) {
      return false;
    }
    summary = evt.summary;
    if (summary == null) {
      return false;
    }
    return !(summary.includes('[ditchable]') || summary.includes('[tentative]'));
  };
  is_weekly_recurring = function(evt){
    return evt.recurrence != null && evt.recurrence.filter(function(it){
      return it.includes('RRULE:FREQ=WEEKLY');
    }).length > 0;
  };
  get_recrule_day_of_week_indexes = function(recrule_list){
    var output, output_set, days, days_to_idx, i$, len$, idx, day, recrule, j$, ref$, len1$, recrule_part, remainder, k$, ref1$, len2$, day_idx;
    output = [];
    output_set = {};
    days = ['SU', 'MO', 'TU', 'WE', 'TH', 'FR', 'SA'];
    days_to_idx = {};
    for (i$ = 0, len$ = days.length; i$ < len$; ++i$) {
      idx = i$;
      day = days[i$];
      days_to_idx[day] = idx;
    }
    for (i$ = 0, len$ = recrule_list.length; i$ < len$; ++i$) {
      recrule = recrule_list[i$];
      for (j$ = 0, len1$ = (ref$ = recrule.split(';')).length; j$ < len1$; ++j$) {
        recrule_part = ref$[j$];
        if (!recrule_part.startsWith('BYDAY=')) {
          continue;
        }
        remainder = recrule_part.substr('BYDAY='.length);
        for (k$ = 0, len2$ = (ref1$ = remainder.split(',')).length; k$ < len2$; ++k$) {
          day = ref1$[k$];
          day_idx = days_to_idx[day];
          if (output_set[day_idx] == null) {
            output.push(day_idx);
            output_set[day_idx] = true;
          }
        }
      }
    }
    return output;
  };
  get_next_time_given_day_of_week_indexes = function(start, day_of_week_indexes){
    var start_day_of_week, greater_day_of_week_indexes, next_day_of_week_idx;
    if (day_of_week_indexes.length === 0) {
      return moment(start).add(1, 'weeks');
    }
    start_day_of_week = start.weekday();
    greater_day_of_week_indexes = day_of_week_indexes.filter(function(it){
      return it > start_day_of_week;
    });
    if (greater_day_of_week_indexes.length > 0) {
      next_day_of_week_idx = greater_day_of_week_indexes[0];
      return moment(start).weekday(next_day_of_week_idx);
    }
    next_day_of_week_idx = day_of_week_indexes[0];
    return moment(start).weekday(next_day_of_week_idx).add(1, 'weeks');
  };
  expand_recurring_events = function(evt_list, start, end){
    var output, i$, len$, evt, day_of_week_indexes, new_start_time, new_evt;
    output = [];
    for (i$ = 0, len$ = evt_list.length; i$ < len$; ++i$) {
      evt = evt_list[i$];
      if (is_weekly_recurring(evt)) {
        day_of_week_indexes = get_recrule_day_of_week_indexes(evt.recurrence);
        new_start_time = moment(new Date(evt.start.dateTime));
        for (;;) {
          if (new_start_time >= end) {
            break;
          }
          if (new_start_time > start) {
            new_evt = JSON.parse(JSON.stringify(evt));
            delete new_evt.recurrence;
            postpone_event_to_day(new_evt, new_start_time);
            output.push(new_evt);
          }
          new_start_time = get_next_time_given_day_of_week_indexes(new_start_time, day_of_week_indexes);
        }
      } else {
        output.push(evt);
      }
    }
    return output;
  };
  create_available_meals = cfy(function*(){
    var timeMin, timeMax, events_available_meals, ref$, ref1$, events_meals, ref2$, ref3$, events_primary, ref4$, ref5$, events_secondary, ref6$, ref7$, events_meals_actual, events_all_actual, current_time, today_start, end_time_recurrence_expansion, all_available_meal_times, i$, days_into_future, day, day_weekday_num, next_day, mealtime_start, mealtime_end, events_mealtime_today, events_all_mealtime_today, available_times, j$, len$, available_time, events_that_should_exist_set, events_that_should_exist, ref8$, start, end, timespan, existing_event_span_to_ids, event_ids_to_delete, event_ids_to_delete_set, evt, eventId, events_to_create, events_to_create_set, start_moment, end_moment, event_type, results$ = [];
    timeMin = moment().format("YYYY-MM-DDTHH:mm:ssZ");
    timeMax = moment().add(31, 'days').format("YYYY-MM-DDTHH:mm:ssZ");
    events_available_meals = (ref$ = (yield function(it){
      return calendar.events.list({
        auth: auth,
        calendarId: calendarId,
        timeMin: timeMin,
        timeMax: timeMax
      }, {}, it);
    })) != null ? (ref1$ = ref$[0]) != null ? ref1$.items : void 8 : void 8;
    events_meals = (ref2$ = (yield function(it){
      return calendar.events.list({
        auth: auth,
        calendarId: meals_calendarId,
        timeMin: timeMin,
        timeMax: timeMax
      }, {}, it);
    })) != null ? (ref3$ = ref2$[0]) != null ? ref3$.items : void 8 : void 8;
    events_primary = (ref4$ = (yield function(it){
      return calendar.events.list({
        auth: auth,
        calendarId: primary_calendarId,
        timeMin: timeMin,
        timeMax: timeMax
      }, {}, it);
    })) != null ? (ref5$ = ref4$[0]) != null ? ref5$.items : void 8 : void 8;
    events_secondary = (ref6$ = (yield function(it){
      return calendar.events.list({
        auth: auth,
        calendarId: secondary_calendarId,
        timeMin: timeMin,
        timeMax: timeMax
      }, {}, it);
    })) != null ? (ref7$ = ref6$[0]) != null ? ref7$.items : void 8 : void 8;
    events_meals_actual = events_meals.filter(nonditchable_and_nontentative);
    events_all_actual = events_primary.concat(events_secondary).concat(events_meals).filter(nonditchable_and_nontentative);
    current_time = moment();
    today_start = moment(current_time).hours(0).minutes(0).seconds(0).milliseconds(0);
    end_time_recurrence_expansion = moment(today_start).add(31, 'days');
    events_meals_actual = expand_recurring_events(events_meals_actual, today_start, end_time_recurrence_expansion);
    events_all_actual = expand_recurring_events(events_all_actual, today_start, end_time_recurrence_expansion);
    all_available_meal_times = [];
    for (i$ = 0; i$ < 30; ++i$) {
      days_into_future = i$;
      day = moment(today_start).add(days_into_future, 'days');
      day_weekday_num = day.weekday();
      if (day_weekday_num === 6 || day_weekday_num === 0) {
        continue;
      }
      next_day = moment(day).add(1, 'days');
      mealtime_start = moment(day).hours(11);
      mealtime_end = moment(day).hours(14);
      events_mealtime_today = events_meals_actual.filter(fn$);
      if (events_mealtime_today.length === 0) {
        events_all_mealtime_today = events_all_actual.filter(fn1$);
        available_times = get_nonconflicting_spans(events_all_mealtime_today, mealtime_start, mealtime_end);
        for (j$ = 0, len$ = available_times.length; j$ < len$; ++j$) {
          available_time = available_times[j$];
          all_available_meal_times.push(available_time);
        }
      }
      mealtime_start = moment(day).hours(17).minutes(0);
      mealtime_end = moment(day).hours(20).minutes(30);
      events_mealtime_today = events_meals_actual.filter(fn2$);
      if (events_mealtime_today.length === 0) {
        events_all_mealtime_today = events_all_actual.filter(fn3$);
        available_times = get_nonconflicting_spans(events_all_mealtime_today, mealtime_start, mealtime_end);
        for (j$ = 0, len$ = available_times.length; j$ < len$; ++j$) {
          available_time = available_times[j$];
          all_available_meal_times.push(available_time);
        }
      }
    }
    events_that_should_exist_set = {};
    events_that_should_exist = [];
    for (i$ = 0, len$ = all_available_meal_times.length; i$ < len$; ++i$) {
      ref8$ = all_available_meal_times[i$], start = ref8$.start, end = ref8$.end;
      timespan = start.format("YYYY-MM-DDTHH:mm:ssZ") + '|' + end.format("YYYY-MM-DDTHH:mm:ssZ");
      if (events_that_should_exist_set[timespan] == null) {
        events_that_should_exist_set[timespan] = true;
        events_that_should_exist.push(timespan);
      }
    }
    existing_event_span_to_ids = {};
    event_ids_to_delete = [];
    event_ids_to_delete_set = {};
    for (i$ = 0, len$ = events_available_meals.length; i$ < len$; ++i$) {
      evt = events_available_meals[i$];
      if (evt.start == null || evt.id == null || evt.end == null) {
        continue;
      }
      eventId = evt.id;
      start = moment(new Date(evt.start.dateTime)).format("YYYY-MM-DDTHH:mm:ssZ");
      end = moment(new Date(evt.end.dateTime)).format("YYYY-MM-DDTHH:mm:ssZ");
      timespan = start + '|' + end;
      existing_event_span_to_ids[timespan] = eventId;
      if (events_that_should_exist_set[timespan] == null) {
        if (!event_ids_to_delete_set[eventId]) {
          event_ids_to_delete_set[eventId] = true;
          event_ids_to_delete.push(eventId);
        }
      }
    }
    events_to_create = [];
    events_to_create_set = {};
    for (i$ = 0, len$ = events_that_should_exist.length; i$ < len$; ++i$) {
      timespan = events_that_should_exist[i$];
      if (existing_event_span_to_ids[timespan] == null) {
        if (!events_to_create_set[timespan]) {
          events_to_create_set[timespan] = true;
          events_to_create.push(timespan);
        }
      }
    }
    for (i$ = 0, len$ = event_ids_to_delete.length; i$ < len$; ++i$) {
      eventId = event_ids_to_delete[i$];
      (yield fn4$);
    }
    for (i$ = 0, len$ = events_to_create.length; i$ < len$; ++i$) {
      timespan = events_to_create[i$];
      ref8$ = timespan.split('|'), start = ref8$[0], end = ref8$[1];
      start_moment = moment(new Date(start));
      end_moment = moment(new Date(end));
      event_type = '[lunch]';
      if (start_moment.hours() > 15) {
        event_type = '[dinner]';
      }
      results$.push((yield fn5$));
    }
    return results$;
    function fn$(it){
      return is_between_time(it, mealtime_start, mealtime_end);
    }
    function fn1$(it){
      return is_between_time(it, mealtime_start, mealtime_end);
    }
    function fn2$(it){
      return is_between_time(it, mealtime_start, mealtime_end);
    }
    function fn3$(it){
      return is_between_time(it, mealtime_start, mealtime_end);
    }
    function fn4$(it){
      return calendar.events['delete']({
        auth: auth,
        calendarId: calendarId,
        eventId: eventId
      }, {}, it);
    }
    function fn5$(it){
      return calendar.events.insert({
        auth: auth,
        calendarId: calendarId,
        resource: {
          description: '<a href="https://calendly.com/geza/60min/' + start_moment.format('MM-DD-YYYY') + '">https://www.gkovacs.com/meet</a>',
          start: {
            dateTime: start
          },
          end: {
            dateTime: end
          },
          summary: event_type + ' available ' + start_moment.format('h:mma') + '-' + end_moment.format('h:mma') + ' click to book'
        }
      }, {}, it);
    }
  });
  replace_calendly_urls();
  create_available_meals();
  function repeatArray$(arr, n){
    for (var r = []; n > 0; (n >>= 1) && (arr = arr.concat(arr)))
      if (n & 1) r.push.apply(r, arr);
    return r;
  }
}).call(this);
